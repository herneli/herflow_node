{"version":3,"sources":["../../src/oauth2/OAuthModel.js"],"names":["InMemoryCache","clients","clientId","clientSecret","redirectUris","grants","tokens","users","id","username","name","password","console","log","bearerToken","secret","process","env","JWT_SECRET","token","jwt","verify","accessTokenExpiresAt","moment","unix","exp","toDate","client_id","aud","user","sub","error","message","filter","refreshToken","length","client","tokenData","accessToken","refreshTokenExpiresAt","userId","scope","iss","JWT_ISSUER","sign","expiresIn"],"mappings":"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","file":"OAuthModel.js","sourcesContent":["import jwt from \"jsonwebtoken\";\r\nimport moment from \"moment\";\r\n/**\r\n * Constructor.\r\n */\r\n\r\nclass InMemoryCache {\r\n  constructor() {\r\n    this.clients = [\r\n      {\r\n        clientId: \"client01\",\r\n        clientSecret: \"secret01\",\r\n        redirectUris: [\"\"],\r\n        grants: [\"password\"]\r\n      }\r\n    ];\r\n    this.tokens = [];\r\n    this.users = [\r\n      {\r\n        id: \"1\",\r\n        username: \"jordi\",\r\n        name: \"Jordi Hern√°ndez Amo\",\r\n        password: \"pass\"\r\n      }\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Dump the cache.\r\n   */\r\n\r\n  dump() {\r\n    console.log(\"clients\", this.clients);\r\n    console.log(\"tokens\", this.tokens);\r\n    console.log(\"users\", this.users);\r\n  }\r\n\r\n  getAccessToken(bearerToken) {\r\n    // var tokens = this.tokens.filter(function(token) {\r\n    //   return token.accessToken === bearerToken;\r\n    // });\r\n\r\n    // return tokens.length ? tokens[0] : false;\r\n    const secret = process.env.JWT_SECRET;\r\n    try {\r\n      let token = jwt.verify(bearerToken, secret);\r\n      return {\r\n        accessTokenExpiresAt: moment.unix(token.exp).toDate(),\r\n        client_id: token.aud,\r\n        user: token.sub\r\n      };\r\n    } catch (error) {\r\n      console.log(error.message);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  getRefreshToken(bearerToken) {\r\n    var tokens = this.tokens.filter(function(token) {\r\n      return token.refreshToken === bearerToken;\r\n    });\r\n\r\n    return tokens.length ? tokens[0] : false;\r\n  }\r\n\r\n  getClient(clientId, clientSecret) {\r\n    var clients = this.clients.filter(function(client) {\r\n      return client.clientId === clientId;\r\n    });\r\n\r\n    return clients.length ? clients[0] : false;\r\n  }\r\n\r\n  saveToken(token, client, user) {\r\n    let tokenData = {\r\n      accessToken: token.accessToken,\r\n      accessTokenExpiresAt: token.accessTokenExpiresAt,\r\n      clientId: client.clientId,\r\n      client: client,\r\n      refreshToken: token.refreshToken,\r\n      refreshTokenExpiresAt: token.refreshTokenExpiresAt,\r\n      userId: user.id,\r\n      user: user\r\n    };\r\n    //this.tokens.push(tokenData);\r\n    return tokenData;\r\n  }\r\n\r\n  getUser(username, password) {\r\n    var users = this.users.filter(function(user) {\r\n      return user.username === username && user.password === password;\r\n    });\r\n\r\n    return users.length ? users[0] : false;\r\n  }\r\n\r\n  generateAccessToken(client, user, scope) {\r\n    const secret = process.env.JWT_SECRET;\r\n    const iss = process.env.JWT_ISSUER;\r\n    return jwt.sign(\r\n      { name: user.name, aud: client.clientId, iss, sub: user.username },\r\n      secret,\r\n      {\r\n        expiresIn: 60 * 30\r\n      }\r\n    );\r\n  }\r\n}\r\nexport default InMemoryCache;\r\n"]}